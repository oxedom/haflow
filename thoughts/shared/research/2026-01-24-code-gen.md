## Research Question

How will artifacts work when Haflow is used to run coding agents on external projects (linked via CLI)? The system needs to support two modes: document-processing (current) and code-generation (new). How should Docker containers be configured to support both?

## Summary

**The codebase is NOT ready for the code-generation workflow**, but the existing artifact-based workflow is functional and should be preserved. The system should support **two distinct modes**:

1. **Document-processing mode** (current, working): Claude works on `/mission/artifacts/` - markdown files passed between workflow steps. This is useful for research, planning, and document generation tasks.

2. **Code-generation mode** (new, not implemented): Claude works on a cloned/linked workspace for actual code changes. This is needed for coding agent tasks.

**Important**: These modes should coexist. We must NOT break existing behavior - the mode should be determined by mission type or explicit configuration.

Currently there is **no mechanism** to:
- Mount the linked project into containers (for code-generation mode)
- Let Claude make code changes to the actual project

## Detailed Findings

### 1. CLI: Project Linking (Implemented but Unused)

The CLI has a `link` command that saves the project path:

```1:35:/home/s-linux/projects/haflow/packages/cli/src/index.ts
// link
program
  .command('link [path]')
  .description('Link a project')
  .action(async (path?: string) => {
    const target = resolve(path || process.cwd());
    await saveConfig({ linkedProject: target });
    console.log(`Linked: ${target}`);
  });
```

This is stored in `~/.haflow/config.json`:

```typescript
interface Config {
  linkedProject?: string;
}
```

**Problem**: The `linkedProject` is NEVER passed to the backend or used by containers.

### 2. Backend: No Knowledge of Linked Project

The backend config (`packages/backend/src/utils/config.ts`) has no concept of linked projects:

```9:21:/home/s-linux/projects/haflow/packages/backend/src/utils/config.ts
export const config = {
  port: parseInt(process.env.PORT || '4000', 10),
  haflowHome: process.env.HAFLOW_HOME || join(homedir(), '.haflow'),
  openaiApiKey: process.env.OPENAI_API_KEY || '',
  haflowClaudeDir: join(repoRoot, '.claude'),
  get missionsDir() {
    return join(this.haflowHome, 'missions');
  },
};
```

### 3. Docker Container Mounts (Current State)

When Claude runs in a container, it only mounts:

```274:289:/home/s-linux/projects/haflow/packages/backend/src/services/docker.ts
const args = [
  'run',
  '--name', containerName,
  '-i',
  '--user', `${process.getuid?.() ?? 1000}:${process.getgid?.() ?? 1000}`,
  '-v', `${artifactsPath}:${workingDir}/artifacts`,           // <-- Only artifacts!
  '-v', `${claudeAuthPath}:/home/agent/.claude/.credentials.json:ro`,
  '-w', workingDir,
  defaultImage,
  'claude',
  ...
];
```

**What's mounted:**
- `~/.haflow/missions/<id>/artifacts/` → `/mission/artifacts/` (read-write)
- `~/.claude/.credentials.json` → `/home/agent/.claude/.credentials.json` (read-only)
- `~/.gitconfig` → `/home/agent/.gitconfig` (read-only, if exists)

**What's NOT mounted:**
- ❌ The linked project directory (needed for code-generation mode)

### 4. Dockerfile Shows Intended Design (Unused)

The Dockerfile's entrypoint has logic for `/workspace`:

```51:57:/home/s-linux/projects/haflow/packages/backend/docker/sandbox-templates/claude-code/entrypoint.sh
# If a project is mounted at /workspace, use it
if [ -d "/workspace" ]; then
    cd /workspace
fi

# Create artifacts directory if it doesn't exist
mkdir -p /workspace/artifacts 2>/dev/null || true
```


**But the backend never mounts the linked project to `/workspace`!**

### 5. Current Workflow Step Artifacts (Document-Processing Mode)

The current workflow system expects markdown artifacts (this should continue to work):

```8:17:/home/s-linux/projects/haflow/packages/backend/src/services/workflow.ts
steps: [
  { step_id: 'cleanup', inputArtifact: 'raw-input.md', outputArtifact: 'structured-text.md' },
  { step_id: 'review-structured', reviewArtifact: 'structured-text.md' },
  { step_id: 'research', inputArtifact: 'structured-text.md', outputArtifact: 'research-output.md' },
  // ...
  { step_id: 'implementation', inputArtifact: 'implementation-plan.md', outputArtifact: 'implementation-result.json' },
]
```

The final step outputs `implementation-result.json` with metadata:

```json
{
  "status": "completed" | "partial" | "blocked",
  "filesCreated": ["path/to/file1", ...],
  "filesModified": ["path/to/file2", ...],
  "testsAdded": ["test descriptions..."],
  "notes": "any important notes about the implementation"
}
```

In document-processing mode, this is just metadata about what WOULD be changed (appropriate for planning). In code-generation mode, Claude would make actual changes to `/workspace`.

### 6. Frontend Artifact Display (Human Editing Enabled)

The frontend currently allows editing artifacts in a textarea:

```319:327:/home/s-linux/projects/haflow/packages/frontend/src/components/MissionDetail.tsx
{viewMode === 'editor' ? (
  <Textarea
    data-testid="artifact-editor"
    value={editorContent}
    onChange={(e) => {
      setEditorContent(e.target.value)
      setHasChanges(true)
    }}
    className="w-full h-full min-h-75 font-mono text-sm resize-none"
  />
```

There's already a diff viewer component:

```123:187:/home/s-linux/projects/haflow/packages/frontend/src/components/MissionDetail.tsx
function DiffViewer({ original, modified }: DiffViewerProps) {
  const diffResult = useMemo(() => {
    return Diff.diffLines(original, modified)
  }, [original, modified])
  // ... renders additions/removals with color coding
}
```

## Architecture Gap Analysis

**Key Principle**: Support dual modes without breaking existing artifact-based workflow.

| Requirement | Current State | Needed |
|-------------|---------------|--------|
| Document-processing mode | ✅ Working | Preserve as-is |
| Link external project | ✅ CLI saves path | Backend must read it |
| Mount project in container | ❌ Not implemented | Add `-v linkedProject:/workspace` (code-gen mode only) |
| Claude makes code changes | ✅ Works on `/mission/artifacts/` | ALSO support `/workspace` for code-gen mode |
| Mode selection | ❌ Not implemented | Mission type or config determines working directory |
| Display diff in UI | ✅ DiffViewer exists | Adapt for git diff format (future) |


## Code References

- CLI link command: `packages/cli/src/index.ts:22-32`
- CLI config storage: `packages/cli/src/config.ts:9-11`
- Backend config (missing linked project): `packages/backend/src/utils/config.ts:9-22`
- Docker container start: `packages/backend/src/services/docker.ts:257-296`
- Sandbox options interface: `packages/backend/src/services/sandbox.ts:1-20`
- Workflow definitions: `packages/backend/src/services/workflow.ts:4-28`
- Frontend DiffViewer: `packages/frontend/src/components/MissionDetail.tsx:123-187`
- Frontend artifact editor: `packages/frontend/src/components/MissionDetail.tsx:319-327`

## Open Questions

1. **Mode selection**: How should users indicate document-processing vs code-generation mode? Mission type? Explicit flag? Presence of linked project? ANSWER: This is predefind on the workflow STEP
2. **Conflict handling**: What if the project has uncommitted changes when a mission starts? IT SHOULD THROW AN ERROR and not allow the process to start with a warning
3. **Hybrid missions**: Can a single mission use both modes (e.g., research phase as documents, then code-gen)? Yes of course it's accordinly to the step
4. **Workspace isolation**: Should code-gen mode use the linked project directly, or clone it first for safety? it can use the linked project directly

## Conclusion

**The project is NOT ready for the code-generation workflow, but the existing document-processing workflow is functional and must be preserved.**

The system should support two modes:
- **Document mode** (current): `/mission/artifacts/` - for research, planning, document generation
- **Code-gen mode** (new): `/workspace` with linked project - for coding agent tasks

Implementation priorities:

1. **Short-term**: Define mission types/modes, connect CLI config to backend
2. **Medium-term**: Conditionally mount project in containers (code-gen mode only)
3. **Verify**: Both modes work correctly without breaking each other

The Docker entrypoint already has logic to detect `/workspace` - the infrastructure exists, it just needs to be wired together. The key is ensuring backward compatibility so existing artifact-based workflows continue to work unchanged.
